/*******************************************************************************
 *
 * This file is part of pycommute, Python bindings for the libcommute C++
 * quantum operator algebra library.
 *
 * Copyright (C) 2020-2021 Igor Krivenko <igor.s.krivenko@gmail.com>
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 ******************************************************************************/

#include "pybind11_workarounds.hpp"

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

#include <libcommute/loperator/loperator.hpp>
#include <libcommute/loperator/elementary_space_fermion.hpp>
#include <libcommute/loperator/elementary_space_boson.hpp>
#include <libcommute/loperator/elementary_space_spin.hpp>
#include <libcommute/expression/dyn_indices.hpp>

#include <string>

using namespace libcommute;
namespace py = pybind11;

//
// Some commonly used type shorthands
//

using dynamic_indices::dyn_indices;
using es_type = elementary_space<dyn_indices>;

////////////////////////////////////////////////////////////////////////////////

//
// Convert Python positional arguments into dyn_indices::indices_t
//

dyn_indices::indices_t args2indices_t(py::args args) {
  dyn_indices::indices_t v;
  v.reserve(args.size());
  for(auto const& a : args)
    v.emplace_back(a.cast<std::variant<int, std::string>>());
  return v;
}

////////////////////////////////////////////////////////////////////////////////

//
// Helper classes for abstract base elementary_space<dyn_indices>
//

class es_type_trampoline : public es_type {

  dyn_indices init(py::args args) {
    dyn_indices::indices_t v;
    v.reserve(args.size());
    for(auto const& a : args)
      v.emplace_back(a.cast<std::variant<int, std::string>>());
    return dyn_indices(std::move(v));
  }

  public:

  using es_type::es_type;

  es_type_trampoline(py::args args) : es_type(std::move(init(args))) {}

  int algebra_id() const override {
    PYBIND11_OVERRIDE_PURE(int, es_type, algebra_id, );
  }

  std::unique_ptr<es_type> clone() const override {
    // elementary spaces are immutable, so one should use multiple references
    // instead of creating deep copies in Python.
    assert(false);
    return nullptr;
  }

  int n_bits() const override {
    PYBIND11_OVERRIDE(int, es_type, n_bits, );
  }
};

//
// Register elementary_space<dyn_indices>
//

void register_elementary_space(py::module_ & m) {

  py::class_<es_type, es_type_trampoline>(m, "ElementarySpace",
    "Hilbert space corresponding to one quantum degree of freedom"
  )
  // Algebra ID
  .def_property_readonly(
    "algebra_id",
    &es_type::algebra_id,
    "ID of the algebra this elementary space is associated with."
  )
  // The minimal number of binary digits needed to represent any state
  // in this elementary space
  .def_property_readonly(
    "n_bits",
    &es_type::n_bits,
    "The minimal number of binary digits needed to represent any state "
    "in this elementary space."
  )
  // Tuple of indices
  .def_property_readonly("indices", [](es_type const& es){
    return std::get<0>(es.indices());
    },
    "Indices carried by this elementary space."
  )
  // Comparison operators
  .def("__eq__",
       [](es_type const& es1, es_type const& es2){ return es1 == es2; },
       py::is_operator(),
    py::arg("es2")
  )
  .def("__ne__",
       [](es_type const& es1, es_type const& es2){ return es1 != es2; },
       py::is_operator(),
       py::arg("es2")
  )
  .def("__lt__",
       [](es_type const& es1, es_type const& es2){ return es1 < es2; },
       py::is_operator(),
       py::arg("es2")
  )
  .def("__gt__",
       [](es_type const& es1, es_type const& es2){ return es1 > es2; },
       py::is_operator(),
       py::arg("es2")
  );
}

////////////////////////////////////////////////////////////////////////////////

//
// Register elementary_space_fermion<dyn_indices>
//

void register_elementary_space_fermion(py::module_ & m) {

  py::class_<elementary_space_fermion<dyn_indices>, es_type>(
    m,
    "ESpaceFermion",
    "Elementary space generated by one fermionic degree of freedom"
  )
  .def(py::init<dyn_indices const&>(),
R"=(
Construct a 2-dimensional elementary space a fermionic creation/annihilation
operator acts in.

:param indices: Index sequence of the corresponding creation/annihilation operator.
)=",
    py::arg("indices")
  );

  m.def("make_space_fermion", [](py::args args) {
    return elementary_space_fermion<dyn_indices>(args2indices_t(args));
  },
R"=(
Make a fermionic elementary space with indices passed as positional arguments.

:param *args: Indices of the corresponding creation/annihilation operator.
)="
  );
}

////////////////////////////////////////////////////////////////////////////////

//
// Register elementary_space_boson<dyn_indices>
//

void register_elementary_space_boson(py::module_ & m) {

  py::class_<elementary_space_boson<dyn_indices>, es_type>(
    m,
    "ESpaceBoson",
    "Truncated :math:`2^n`-dimensional elementary space generated by one "
    "bosonic degree of freedom"
  )
  .def(py::init<int, dyn_indices const&>(),
R"=(
Construct a :math:`2^\text{n_bits}`-dimensional elementary space a bosonic
creation/annihilation operator acts in.

:param n_bits: Base-2 logarithm of the required space dimension.
:param indices: Index sequence of the creation/annihilation operator.
)=",
    py::arg("n_bits"), py::arg("indices"));

  m.def("make_space_boson", [](int n_bits, py::args args) {
    return elementary_space_boson<dyn_indices>(n_bits, args2indices_t(args));
  },
R"=(
Make a bosonic elementary space with indices passed as positional arguments.

:param n_bits: Base-2 logarithm of the required space dimension.
:param *args: Indices of the corresponding creation/annihilation operator.
)=",
    py::arg("n_bits")
  );
}

////////////////////////////////////////////////////////////////////////////////

//
// Register register_elementary_space_spin<dyn_indices>
//

void register_elementary_space_spin(py::module_ & m) {

  py::class_<elementary_space_spin<dyn_indices>, es_type>(
    m,
    "ESpaceSpin",
    "Elementary space generated by one spin degree of freedom"
  )
  .def(py::init<double, dyn_indices const&>(),
R"=(
Construct an elementary space spin-:math:`S` operators act in.

:param spin: Integer or half-integer value of spin :math:`S`.
:param indices: Index sequence of the corresponding spin operator.
)=",
    py::arg("spin"), py::arg("indices")
  );

  m.def("make_space_spin", [](double spin, py::args args) {
    return elementary_space_spin<dyn_indices>(spin, args2indices_t(args));
  },
R"=(
Make a spin elementary space with indices passed as positional arguments.

:param spin: Integer or half-integer value of spin :math:`S`.
:param *args: Indices of the corresponding spin operator.
)=",
    py::arg("spin")
);

}

////////////////////////////////////////////////////////////////////////////////

//
// 'loperator' Python module
//

PYBIND11_MODULE(loperator, m) {

  m.doc() = "Linear operators in finite-dimensional Hilbert spaces and "
            "Exact Diagonalization toolkit";

  register_elementary_space(m);

  register_elementary_space_fermion(m);
  register_elementary_space_boson(m);
  register_elementary_space_spin(m);
}
