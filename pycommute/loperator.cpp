/*******************************************************************************
 *
 * This file is part of pycommute, Python bindings for the libcommute C++
 * quantum operator algebra library.
 *
 * Copyright (C) 2020-2021 Igor Krivenko <igor.s.krivenko@gmail.com>
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 ******************************************************************************/

#include "pybind11_workarounds.hpp"

#include <pybind11/pybind11.h>
#include <pybind11/operators.h>
#include <pybind11/stl.h>
#include <pybind11/functional.h>

#include "numpy_state_vectors.hpp"

#include <libcommute/loperator/loperator.hpp>
#include <libcommute/loperator/elementary_space_fermion.hpp>
#include <libcommute/loperator/elementary_space_boson.hpp>
#include <libcommute/loperator/elementary_space_spin.hpp>
#include <libcommute/loperator/es_constructor.hpp>
#include <libcommute/expression/dyn_indices.hpp>

#include <string>
#include <type_traits>
#include <utility>

using namespace libcommute;
namespace py = pybind11;

//
// Some commonly used type shorthands
//

using dynamic_indices::dyn_indices;
using es_type = elementary_space<dyn_indices>;
using hs_type = hilbert_space<dyn_indices>;

////////////////////////////////////////////////////////////////////////////////

//
// Convert Python positional arguments into dyn_indices::indices_t
//

dyn_indices::indices_t args2indices_t(py::args args) {
  dyn_indices::indices_t v;
  v.reserve(args.size());
  for(auto const& a : args)
    v.emplace_back(a.cast<std::variant<int, std::string>>());
  return v;
}

////////////////////////////////////////////////////////////////////////////////

//
// Helper classes for abstract base elementary_space<dyn_indices>
//

class es_type_trampoline : public es_type {

  dyn_indices init(py::args args) {
    dyn_indices::indices_t v;
    v.reserve(args.size());
    for(auto const& a : args)
      v.emplace_back(a.cast<std::variant<int, std::string>>());
    return dyn_indices(std::move(v));
  }

  public:

  using es_type::es_type;

  es_type_trampoline(py::args args) : es_type(std::move(init(args))) {}

  int algebra_id() const override {
    PYBIND11_OVERRIDE_PURE(int, es_type, algebra_id, );
  }

  std::unique_ptr<es_type> clone() const override {
    // elementary spaces are immutable, so one should use multiple references
    // instead of creating deep copies in Python.
    assert(false);
    return nullptr;
  }

  int n_bits() const override {
    PYBIND11_OVERRIDE(int, es_type, n_bits, );
  }
};

//
// Register elementary_space<dyn_indices>
//

void register_elementary_space(py::module_ & m) {

  py::class_<es_type, es_type_trampoline>(m, "ElementarySpace",
    "Hilbert space corresponding to one quantum degree of freedom"
  )
  // Algebra ID
  .def_property_readonly(
    "algebra_id",
    &es_type::algebra_id,
    "ID of the algebra this elementary space is associated with."
  )
  // The minimal number of binary digits needed to represent any state
  // in this elementary space
  .def_property_readonly(
    "n_bits",
    &es_type::n_bits,
    "The minimal number of binary digits needed to represent any state "
    "in this elementary space."
  )
  // Tuple of indices
  .def_property_readonly("indices", [](es_type const& es){
    return std::get<0>(es.indices());
    },
    "Indices carried by this elementary space."
  )
  // Comparison operators
  .def("__eq__",
       [](es_type const& es1, es_type const& es2){ return es1 == es2; },
       py::is_operator(),
    py::arg("es2")
  )
  .def("__ne__",
       [](es_type const& es1, es_type const& es2){ return es1 != es2; },
       py::is_operator(),
       py::arg("es2")
  )
  .def("__lt__",
       [](es_type const& es1, es_type const& es2){ return es1 < es2; },
       py::is_operator(),
       py::arg("es2")
  )
  .def("__gt__",
       [](es_type const& es1, es_type const& es2){ return es1 > es2; },
       py::is_operator(),
       py::arg("es2")
  );
}

////////////////////////////////////////////////////////////////////////////////

//
// Register elementary_space_fermion<dyn_indices>
//

void register_elementary_space_fermion(py::module_ & m) {

  py::class_<elementary_space_fermion<dyn_indices>, es_type>(
    m,
    "ESpaceFermion",
    "Elementary space generated by one fermionic degree of freedom"
  )
  .def(py::init<dyn_indices const&>(),
R"=(
Construct a 2-dimensional elementary space a fermionic creation/annihilation
operator acts in.

:param indices: Index sequence of the corresponding creation/annihilation operator.
)=",
    py::arg("indices")
  );

  m.def("make_space_fermion", [](py::args args) {
    return elementary_space_fermion<dyn_indices>(args2indices_t(args));
  },
R"=(
Make a fermionic elementary space with indices passed as positional arguments.

:param *args: Indices of the corresponding creation/annihilation operator.
)="
  );
}

////////////////////////////////////////////////////////////////////////////////

//
// Register elementary_space_boson<dyn_indices>
//

void register_elementary_space_boson(py::module_ & m) {

  py::class_<elementary_space_boson<dyn_indices>, es_type>(
    m,
    "ESpaceBoson",
    "Truncated :math:`2^n`-dimensional elementary space generated by one "
    "bosonic degree of freedom"
  )
  .def(py::init<int, dyn_indices const&>(),
R"=(
Construct a :math:`2^\text{n_bits}`-dimensional elementary space a bosonic
creation/annihilation operator acts in.

:param n_bits: Base-2 logarithm of the required space dimension.
:param indices: Index sequence of the creation/annihilation operator.
)=",
    py::arg("n_bits"), py::arg("indices"));

  m.def("make_space_boson", [](int n_bits, py::args args) {
    return elementary_space_boson<dyn_indices>(n_bits, args2indices_t(args));
  },
R"=(
Make a bosonic elementary space with indices passed as positional arguments.

:param n_bits: Base-2 logarithm of the required space dimension.
:param *args: Indices of the corresponding creation/annihilation operator.
)=",
    py::arg("n_bits")
  );
}

////////////////////////////////////////////////////////////////////////////////

//
// Register register_elementary_space_spin<dyn_indices>
//

void register_elementary_space_spin(py::module_ & m) {

  py::class_<elementary_space_spin<dyn_indices>, es_type>(
    m,
    "ESpaceSpin",
    "Elementary space generated by one spin degree of freedom"
  )
  .def(py::init<double, dyn_indices const&>(),
R"=(
Construct an elementary space spin-:math:`S` operators act in.

:param spin: Integer or half-integer value of spin :math:`S`.
:param indices: Index sequence of the corresponding spin operator.
)=",
    py::arg("spin"), py::arg("indices")
  );

  m.def("make_space_spin", [](double spin, py::args args) {
    return elementary_space_spin<dyn_indices>(spin, args2indices_t(args));
  },
R"=(
Make a spin elementary space with indices passed as positional arguments.

:param spin: Integer or half-integer value of spin :math:`S`.
:param *args: Indices of the corresponding spin operator.
)=",
    py::arg("spin")
  );
}

////////////////////////////////////////////////////////////////////////////////

//
// Register hilbert_space<dyn_indices>
//

void register_hilbert_space(py::module_ & m) {

  using dynamic_indices::expr_real;
  using dynamic_indices::expr_complex;

  py::class_<hs_type>(m, "HilbertSpace",
    "Hilbert space as a direct product of elementary spaces"
  )
  .def(py::init<>(), "Construct an empty Hilbert space.")
  .def(py::init<std::vector<es_type*> const&>(),
    "Construct from a list to elementary spaces.",
    py::arg("elementary_spaces")
  )
  .def(py::init(
    [](expr_real const& expr, int bits_per_boson) {
      return hs_type(expr, boson_es_constructor(bits_per_boson));
    }),
R"=(
Inspect a real polynomial expression and collect elementary spaces associated to
every algebra generator found in the expression.

:param expr: Polynomial expression to inspect.
:param bits_per_boson: Base-2 logarithm of the dimension of every bosonic
       elementary space to be constructed.
)=",
    py::arg("expr"), py::arg("bits_per_boson") = 1
  )
  .def(py::init(
    [](expr_complex const& expr, int bits_per_boson) {
      return hs_type(expr, boson_es_constructor(bits_per_boson));
    }),
R"=(
Inspect a complex polynomial expression and collect elementary spaces associated
to every algebra generator found in the expression.

:param expr: Polynomial expression to inspect.
:param bits_per_boson: Base-2 logarithm of the dimension of every bosonic
       elementary space to be constructed.
)=",
    py::arg("expr"), py::arg("bits_per_boson") = 1
  )
  .def(py::self == py::self, py::arg("hs"))
  .def(py::self != py::self, py::arg("hs"))
  .def("add",
    &hs_type::add,
R"=(
Add a new elementary space into the direct product.

:param es: Elementary space to add.
)=",
    py::arg("es")
  )
  .def("__contains__",
    &hs_type::has,
    "Is a given elementary space part of the direct product?",
    py::arg("es")
  )
  .def("__len__",
    &hs_type::size,
    "Number of elementary spaces in the direct product."
  )
  .def_property_readonly("dim",
    &hs_type::dim,
    "Dimension of this Hilbert space, :math:`2^\\text{total_n_bits}`."
  )
  .def("bit_range",
    &hs_type::bit_range,
R"=(
Bit range spanned by a given elementary space.

:param es: Elementary space.
)=",
    py::arg("es")
  )
  .def("algebra_bit_range",
    &hs_type::algebra_bit_range,
R"=(
Bit range spanned by a given algebra ID.

:param algebra_id: Algebra ID.
)=",
  py::arg("algebra_id")
  )
  .def_property_readonly("total_n_bits",
    &hs_type::total_n_bits,
R"=(The minimal number of binary digits needed to represent any state in this
Hilbert space.)="
  )
  .def("basis_state_index",
    &hs_type::basis_state_index,
R"=(
Returns index of the product basis state, which decomposes over bases of
the elementary spaces as
:math:`|0\rangle |0\rangle \ldots |0\rangle |n\rangle_\text{es} |0\rangle
\ldots |0\rangle`.

:param es: Elementary space corresponding to the arbitrary index in
           the decomposition.
:param n: Index of the basis state within the selected elementary space.
)=", py::arg("es"), py::arg("n")
  );

  // foreach()
  using f_t = std::function<void(sv_index_type n)>;

  m.def("foreach",
        [](hs_type const& hs, f_t const& f) { return foreach(hs, f); },
R"=(
Apply a given functor to all basis state indices in a Hilbert space.

:param hs: Hilbert space in question.
:param f: Functor to be applied.
)=",
    py::arg("hs"), py::arg("f")
  );
}

////////////////////////////////////////////////////////////////////////////////

template<typename ScalarType>
using lop_type = loperator<ScalarType, fermion, boson, spin>;

//
// Register loperator<ScalarType, fermion, boson, spin>::operator()()
//

template<typename ScalarType, typename SrcScalarType, typename DstScalarType>
void register_loperator_act(py::class_<lop_type<ScalarType>> & lop) {

  std::string src_vector_text = std::is_same_v<SrcScalarType, double> ?
                                "real" : "complex";
  std::string dst_vector_text = std::is_same_v<DstScalarType, double> ?
                                "real" : "complex";
  auto docstring = "\nAct on a " + src_vector_text +
    " state vector and write the result into another " + dst_vector_text +
    " state vector.\n" +
    R"=(
:param src: Source state vector.
:param dst: Destination state vector.
)=";

  lop.def("__call__",
    [](lop_type<ScalarType> const& op,
       py::array_t<SrcScalarType> const& src,
       py::array_t<DstScalarType> & dst
      ) {
      py::buffer_info src_buf = src.request();
      py::buffer_info dst_buf = dst.request();
      if(src_buf.ndim != 1)
        throw std::runtime_error(
          "Source state vector must be a 1-dimensional array"
        );
      if(dst_buf.ndim != 1)
        throw std::runtime_error(
          "Destination state vector must be a 1-dimensional array"
        );
      op(src, dst);
    },
    docstring.c_str(),
    py::is_operator(), py::arg("src"), py::arg("dst").noconvert()
  );
}

//
// Register loperator<ScalarType, fermion, boson, spin>::operator*()
//

template<typename ScalarType, typename StateScalarType>
void register_loperator_mul(py::class_<lop_type<ScalarType>> & lop) {
  using dst_scalar_type = mul_type<ScalarType, StateScalarType>;

  auto docstring = "Act on a " +
    std::string(std::is_same_v<StateScalarType, double> ? "real" : "complex") +
    " state vector and return the resulting vector.";

  lop.def("__mul__",
    [](lop_type<ScalarType> const& op,
       py::array_t<StateScalarType> const& sv) ->
      py::array_t<dst_scalar_type> {
      py::buffer_info sv_buf = sv.request();
      if(sv_buf.ndim != 1)
        throw std::runtime_error("State vector must be a 1-dimensional array");
      auto dst = py::array_t<dst_scalar_type>(sv_buf.size);
      op(sv, dst);
      return dst;
    },
    docstring.c_str(),
    py::is_operator(), py::arg("sv")
  );
}

//
// Register loperator<ScalarType, fermion, boson, spin>
//

template<typename ScalarType>
void register_loperator(py::module_ & m,
                        std::string const& class_name,
                        std::string const& docstring
                       ) {
  py::class_<lop_type<ScalarType>> lop(m,
                                       class_name.c_str(),
                                       docstring.c_str());

  // Constructor
  lop.def(
    py::init<expression<ScalarType, dyn_indices> const&, hs_type const&>(),
R"=(
Construct the linear operator representing action of a given polynomial
expression on a Hilbert space.

:param expr: Source polynomial expression.
:param hs: Hilbert space the linear operator acts on.
)=",
    py::arg("expr"), py::arg("hs")
  );

  // Multiplication (action on a state vector)
  register_loperator_mul<ScalarType, double>(lop);
  register_loperator_mul<ScalarType, std::complex<double>>(lop);

  // Call operator (in-place action on a state vector)
  if constexpr(std::is_same_v<ScalarType, double>)
    register_loperator_act<ScalarType, double, double>(lop);
  register_loperator_act<ScalarType, double, std::complex<double>>(lop);
  register_loperator_act<ScalarType,
                         std::complex<double>,
                         std::complex<double>>(lop);
}

////////////////////////////////////////////////////////////////////////////////

//
// 'loperator' Python module
//

PYBIND11_MODULE(loperator, m) {

  m.doc() = "Linear operators in finite-dimensional Hilbert spaces";

  register_elementary_space(m);

  register_elementary_space_fermion(m);
  register_elementary_space_boson(m);
  register_elementary_space_spin(m);

  register_hilbert_space(m);

  register_loperator<double>(
    m, "LOperatorR", "Real-valued linear operator"
  );
  register_loperator<std::complex<double>>(
    m, "LOperatorC", "Complex-valued linear operator"
  );
}
