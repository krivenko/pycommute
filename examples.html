<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Usage examples &mdash; pycommute 0.7.2 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API reference" href="reference.html" />
    <link rel="prev" title="Installation" href="installation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            pycommute
              <img src="_static/logo_small.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.7.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Usage examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#holstein-model">Holstein model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spin-1-2-heisenberg-chain">Spin-1/2 Heisenberg chain</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spectrum-of-tavis-cummings-model">Spectrum of Tavis-Cummings model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sectors-of-a-multi-orbital-interaction-hamiltonian">Sectors of a multi-orbital interaction Hamiltonian</a></li>
<li class="toctree-l2"><a class="reference internal" href="#n-fermion-sector-views">N-fermion sector views</a></li>
<li class="toctree-l2"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="search.html">Search Page</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pycommute</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Usage examples</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/examples.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="usage-examples">
<span id="examples"></span><h1>Usage examples<a class="headerlink" href="#usage-examples" title="Permalink to this heading"></a></h1>
<section id="holstein-model">
<h2>Holstein model<a class="headerlink" href="#holstein-model" title="Permalink to this heading"></a></h2>
<p>This example shows how to construct Hamiltonian of the
<a class="reference external" href="https://arxiv.org/abs/cond-mat/9812252">Holstein model</a> on a
square lattice and to check that the total number of electrons is a conserved
quantity of the model.</p>
<p>The Hamiltonian considered here is a sum of three terms.</p>
<ul>
<li><p>An electronic tight-binding model on a square lattice with only
nearest-neighbour hopping allowed,</p>
<div class="math notranslate nohighlight">
\[\hat H_\text{e} = -t \sum_\sigma \sum_{\langle i,j\rangle}
                  c^\dagger_{i,\sigma} c_{j,\sigma}.\]</div>
</li>
<li><p>A harmonic oscillator at each lattice site (a localized phonon),</p>
<div class="math notranslate nohighlight">
\[\hat H_\text{ph} = \omega_0 \sum_i a^\dagger_i a_i.\]</div>
</li>
<li><p>A coupling between the electrons and the phonons.</p>
<div class="math notranslate nohighlight">
\[\hat H_\text{e-ph} = g \sum_\sigma \sum_i n_{i,\sigma}(a^\dagger_i + a_i).\]</div>
</li>
</ul>
<p>Instead of writing the sums over lattice sites explicitly, we call library
functions <a class="reference internal" href="models_ref.html#pycommute.models.tight_binding" title="pycommute.models.tight_binding"><code class="xref py py-func docutils literal notranslate"><span class="pre">tight_binding()</span></code></a>,
<a class="reference internal" href="models_ref.html#pycommute.models.dispersion" title="pycommute.models.dispersion"><code class="xref py py-func docutils literal notranslate"><span class="pre">dispersion()</span></code></a> and
<a class="reference internal" href="models_ref.html#pycommute.models.holstein_int" title="pycommute.models.holstein_int"><code class="xref py py-func docutils literal notranslate"><span class="pre">holstein_int()</span></code></a>.
We also make use of the <a class="reference external" href="https://networkx.org/">NetworkX</a> package
to easily generate the adjacency matrix of the periodic square lattice.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">  1</span><span class="c1">#</span>
<span class="linenos">  2</span><span class="c1"># Holstein model on a square lattice with periodic boundary conditions.</span>
<span class="linenos">  3</span><span class="c1">#</span>
<span class="linenos">  4</span>
<span class="linenos">  5</span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="linenos">  6</span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="linenos">  7</span>
<span class="linenos">  8</span><span class="kn">from</span> <span class="nn">pycommute.expression</span> <span class="kn">import</span> <span class="n">ExpressionR</span><span class="p">,</span> <span class="n">conj</span><span class="p">,</span> <span class="n">FERMION</span><span class="p">,</span> <span class="n">BOSON</span>
<span class="linenos">  9</span><span class="kn">from</span> <span class="nn">pycommute.expression</span> <span class="kn">import</span> <span class="n">n</span>
<span class="linenos"> 10</span><span class="kn">from</span> <span class="nn">pycommute.models</span> <span class="kn">import</span> <span class="n">tight_binding</span><span class="p">,</span> <span class="n">dispersion</span><span class="p">,</span> <span class="n">holstein_int</span>
<span class="linenos"> 11</span>
<span class="linenos"> 12</span><span class="kn">from</span> <span class="nn">networkx.generators.lattice</span> <span class="kn">import</span> <span class="n">grid_2d_graph</span>
<span class="linenos"> 13</span><span class="kn">from</span> <span class="nn">networkx.linalg.graphmatrix</span> <span class="kn">import</span> <span class="n">adjacency_matrix</span>
<span class="linenos"> 14</span>
<span class="linenos"> 15</span><span class="c1">#</span>
<span class="linenos"> 16</span><span class="c1"># Let us define Hamiltonian of an electronic tight-binding model</span>
<span class="linenos"> 17</span><span class="c1"># on a square lattice.</span>
<span class="linenos"> 18</span><span class="c1">#</span>
<span class="linenos"> 19</span>
<span class="linenos"> 20</span><span class="c1"># Number of lattice sites in each direction</span>
<span class="linenos"> 21</span><span class="c1"># (the total number of sites is N*N).</span>
<span class="linenos"> 22</span><span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
<span class="linenos"> 23</span>
<span class="linenos"> 24</span><span class="c1"># Electron hopping constant - energy parameter of the TB model.</span>
<span class="linenos"> 25</span><span class="n">t</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="linenos"> 26</span>
<span class="linenos"> 27</span><span class="c1"># Use NetworkX to construct the periodic square lattice (graph)</span>
<span class="linenos"> 28</span><span class="n">lat</span> <span class="o">=</span> <span class="n">grid_2d_graph</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="linenos"> 29</span>
<span class="linenos"> 30</span><span class="c1"># Create lists of indices for electronic spin-up and spin-down operators.</span>
<span class="linenos"> 31</span><span class="c1"># lat.nodes() returns a list of N^2 pairs of site indices (x, y).</span>
<span class="linenos"> 32</span><span class="n">indices_up</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot;up&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">lat</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>
<span class="linenos"> 33</span><span class="n">indices_dn</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">lat</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>
<span class="linenos"> 34</span>
<span class="linenos"> 35</span><span class="c1"># A sum of tight-binding Hamiltonians for both spins.</span>
<span class="linenos"> 36</span><span class="c1"># The hopping matrix passed to tight_binding() is proportional to the</span>
<span class="linenos"> 37</span><span class="c1"># adjacency matrix of the lattice.</span>
<span class="linenos"> 38</span><span class="n">hopping_matrix</span> <span class="o">=</span> <span class="o">-</span><span class="n">t</span> <span class="o">*</span> <span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>
<span class="linenos"> 39</span><span class="n">H_e</span> <span class="o">=</span> <span class="n">tight_binding</span><span class="p">(</span><span class="n">hopping_matrix</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices_up</span><span class="p">)</span> \
<span class="linenos"> 40</span>    <span class="o">+</span> <span class="n">tight_binding</span><span class="p">(</span><span class="n">hopping_matrix</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices_dn</span><span class="p">)</span>
<span class="linenos"> 41</span>
<span class="linenos"> 42</span><span class="c1">#</span>
<span class="linenos"> 43</span><span class="c1"># Hamiltonian of phonons localized at lattice sites.</span>
<span class="linenos"> 44</span><span class="c1">#</span>
<span class="linenos"> 45</span>
<span class="linenos"> 46</span><span class="c1"># Frequency of the localized phonon.</span>
<span class="linenos"> 47</span><span class="n">w0</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="linenos"> 48</span>
<span class="linenos"> 49</span><span class="c1"># A lists of indices for bosonic operators, simply the (x, y) pairs</span>
<span class="linenos"> 50</span><span class="n">indices_phonon</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="linenos"> 51</span>
<span class="linenos"> 52</span><span class="c1"># All N^2 phonons have the same frequency</span>
<span class="linenos"> 53</span><span class="n">phonon_freqs</span> <span class="o">=</span> <span class="n">w0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="linenos"> 54</span><span class="n">H_ph</span> <span class="o">=</span> <span class="n">dispersion</span><span class="p">(</span><span class="n">phonon_freqs</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices_phonon</span><span class="p">,</span> <span class="n">statistics</span><span class="o">=</span><span class="n">BOSON</span><span class="p">)</span>
<span class="linenos"> 55</span>
<span class="linenos"> 56</span><span class="c1">#</span>
<span class="linenos"> 57</span><span class="c1"># Hamiltonian of electron-phonon coupling.</span>
<span class="linenos"> 58</span><span class="c1">#</span>
<span class="linenos"> 59</span>
<span class="linenos"> 60</span><span class="c1"># Electron-phonon coupling constant.</span>
<span class="linenos"> 61</span><span class="n">g</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="linenos"> 62</span>
<span class="linenos"> 63</span><span class="n">H_e_ph</span> <span class="o">=</span> <span class="n">holstein_int</span><span class="p">(</span><span class="n">g</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span>
<span class="linenos"> 64</span>                      <span class="n">indices_up</span><span class="o">=</span><span class="n">indices_up</span><span class="p">,</span>
<span class="linenos"> 65</span>                      <span class="n">indices_dn</span><span class="o">=</span><span class="n">indices_dn</span><span class="p">,</span>
<span class="linenos"> 66</span>                      <span class="n">indices_boson</span><span class="o">=</span><span class="n">indices_phonon</span><span class="p">)</span>
<span class="linenos"> 67</span>
<span class="linenos"> 68</span><span class="c1"># Complete Holstein Hamiltonian.</span>
<span class="linenos"> 69</span><span class="n">H_H</span> <span class="o">=</span> <span class="n">H_e</span> <span class="o">+</span> <span class="n">H_ph</span> <span class="o">+</span> <span class="n">H_e_ph</span>
<span class="linenos"> 70</span>
<span class="linenos"> 71</span><span class="c1"># Print H_H. There will be quite a lot of terms for the 100-site lattice!</span>
<span class="linenos"> 72</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;H_H =&quot;</span><span class="p">,</span> <span class="n">H_H</span><span class="p">)</span>
<span class="linenos"> 73</span>
<span class="linenos"> 74</span><span class="c1"># Check hermiticity of H_H.</span>
<span class="linenos"> 75</span><span class="nb">print</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;H_H - H_H^\dagger =&quot;</span><span class="p">,</span> <span class="n">H_H</span> <span class="o">-</span> <span class="n">conj</span><span class="p">(</span><span class="n">H_H</span><span class="p">))</span>
<span class="linenos"> 76</span>
<span class="linenos"> 77</span><span class="c1"># Check that H_H commutes with the total number of electrons N_e.</span>
<span class="linenos"> 78</span><span class="n">N_e</span> <span class="o">=</span> <span class="n">ExpressionR</span><span class="p">()</span>
<span class="linenos"> 79</span><span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;up&quot;</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">):</span>
<span class="linenos"> 80</span>    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)):</span>
<span class="linenos"> 81</span>        <span class="n">N_e</span> <span class="o">+=</span> <span class="n">n</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">spin</span><span class="p">)</span>
<span class="linenos"> 82</span>
<span class="linenos"> 83</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[H_H, N_e] =&quot;</span><span class="p">,</span> <span class="n">H_H</span> <span class="o">*</span> <span class="n">N_e</span> <span class="o">-</span> <span class="n">N_e</span> <span class="o">*</span> <span class="n">H_H</span><span class="p">)</span>
<span class="linenos"> 84</span>
<span class="linenos"> 85</span><span class="c1">#</span>
<span class="linenos"> 86</span><span class="c1"># Iteration interface</span>
<span class="linenos"> 87</span><span class="c1">#</span>
<span class="linenos"> 88</span>
<span class="linenos"> 89</span><span class="c1"># Iterate over monomial-coefficient pairs in polynomial expression H_H</span>
<span class="linenos"> 90</span><span class="k">for</span> <span class="n">monomial</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">H_H</span><span class="p">:</span>
<span class="linenos"> 91</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Coefficient:&quot;</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>
<span class="linenos"> 92</span>    <span class="c1"># Iterate over algebra generators (creation/annihilation operators)</span>
<span class="linenos"> 93</span>    <span class="c1"># in the monomial</span>
<span class="linenos"> 94</span>    <span class="k">for</span> <span class="n">generator</span> <span class="ow">in</span> <span class="n">monomial</span><span class="p">:</span>
<span class="linenos"> 95</span>        <span class="c1"># Detect what algebra this generator belongs to</span>
<span class="linenos"> 96</span>        <span class="k">if</span> <span class="n">generator</span><span class="o">.</span><span class="n">algebra_id</span> <span class="o">==</span> <span class="n">FERMION</span><span class="p">:</span>
<span class="linenos"> 97</span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Fermionic&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
<span class="linenos"> 98</span>        <span class="k">elif</span> <span class="n">generator</span><span class="o">.</span><span class="n">algebra_id</span> <span class="o">==</span> <span class="n">BOSON</span><span class="p">:</span>
<span class="linenos"> 99</span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Bosonic&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
<span class="linenos">100</span>        <span class="c1"># Creation or annihilation operator?</span>
<span class="linenos">101</span>        <span class="k">if</span> <span class="n">generator</span><span class="o">.</span><span class="n">dagger</span><span class="p">:</span>
<span class="linenos">102</span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;creation operator&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
<span class="linenos">103</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">104</span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;annihilation operator&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
<span class="linenos">105</span>        <span class="c1"># Extract indices carried by the generator</span>
<span class="linenos">106</span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;with indices&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">generator</span><span class="o">.</span><span class="n">indices</span><span class="p">))</span>
<span class="linenos">107</span>        <span class="c1"># N.B. generator.indices is an instance of a special tuple-like type</span>
<span class="linenos">108</span>        <span class="c1"># `pycommute.expression.Indices`. Types of its elements are restricted</span>
<span class="linenos">109</span>        <span class="c1"># to integer and string, and its comparison operators behave differently</span>
<span class="linenos">110</span>        <span class="c1"># from those of the Python tuple. Otherwise, it supports `len()`,</span>
<span class="linenos">111</span>        <span class="c1"># indexed element access and iteration protocol.</span>
</pre></div>
</div>
</section>
<section id="spin-1-2-heisenberg-chain">
<h2>Spin-1/2 Heisenberg chain<a class="headerlink" href="#spin-1-2-heisenberg-chain" title="Permalink to this heading"></a></h2>
<p>The spin-1/2 Heisenberg chain is a textbook example of an integrable quantum
system. Its Hamiltonian</p>
<div class="math notranslate nohighlight">
\[\hat H = g \sum_i \mathbf{S}_i \cdot \mathbf{S}_{i+1}\]</div>
<p>conserves three projections of the total spin</p>
<div class="math notranslate nohighlight">
\[\mathbf{S} = \sum_i \mathbf{S}_i\]</div>
<p>as well as a series of higher order charges <span class="math notranslate nohighlight">\(Q_n\)</span>. Existence of these
charges can be derived from the transfer matrix theory. Explicit expressions
for <span class="math notranslate nohighlight">\(Q_n\)</span> were obtained in <a class="reference internal" href="#gm94" id="id2"><span>[GM94]</span></a>. The following script constructs
Hamiltonian of the Heisenberg chain with periodic boundary conditions
(see <a class="reference internal" href="models_ref.html#pycommute.models.heisenberg" title="pycommute.models.heisenberg"><code class="xref py py-func docutils literal notranslate"><span class="pre">heisenberg()</span></code></a>)
and checks that <span class="math notranslate nohighlight">\([\hat H, \mathbf{S}] = 0\)</span>, <span class="math notranslate nohighlight">\([\hat H, Q_n] = 0\)</span> and
<span class="math notranslate nohighlight">\([Q_n, Q_m] = 0\)</span> for <span class="math notranslate nohighlight">\(m,n = 3,4,5\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">#</span>
<span class="linenos"> 2</span><span class="c1"># Periodic spin-1/2 Heisenberg chain and its integrals of motion</span>
<span class="linenos"> 3</span><span class="c1">#</span>
<span class="linenos"> 4</span><span class="c1"># Expressions for the integrals of motion are taken from</span>
<span class="linenos"> 5</span><span class="c1">#</span>
<span class="linenos"> 6</span><span class="c1">#   &quot;Quantum Integrals of Motion for the Heisenberg Spin Chain&quot;,</span>
<span class="linenos"> 7</span><span class="c1">#   M. P. Grabowski and P. Mathieu</span>
<span class="linenos"> 8</span><span class="c1">#   Mod. Phys. Lett. A, Vol. 09, No. 24, pp. 2197-2206 (1994),</span>
<span class="linenos"> 9</span><span class="c1">#   https://doi.org/10.1142/S0217732394002057</span>
<span class="linenos">10</span><span class="c1">#</span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span> <span class="n">cross</span>
<span class="linenos">13</span><span class="kn">from</span> <span class="nn">pycommute.expression</span> <span class="kn">import</span> <span class="n">S_x</span><span class="p">,</span> <span class="n">S_y</span><span class="p">,</span> <span class="n">S_z</span>
<span class="linenos">14</span><span class="kn">from</span> <span class="nn">pycommute.models</span> <span class="kn">import</span> <span class="n">heisenberg</span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="c1"># Number of spins in the chain</span>
<span class="linenos">17</span><span class="n">N</span> <span class="o">=</span> <span class="mi">20</span>
<span class="linenos">18</span><span class="c1"># Heisenberg exchange constant</span>
<span class="linenos">19</span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span>
<span class="linenos">20</span>
<span class="linenos">21</span><span class="c1"># List of 3-component spin vectors {S_0, S_1, ..., S_{N-1}}</span>
<span class="linenos">22</span><span class="n">S</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span><span class="p">([</span><span class="n">S_x</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">S_y</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">S_z</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
<span class="linenos">23</span>
<span class="linenos">24</span><span class="c1"># Matrix of exchange constants between spins i and j</span>
<span class="linenos">25</span><span class="n">exchange_matrix</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
<span class="linenos">26</span><span class="c1"># Set elements corresponding to the nearest neighbors to -g</span>
<span class="linenos">27</span><span class="c1"># (index shift modulo N ensures periodic boundary conditions).</span>
<span class="linenos">28</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
<span class="linenos">29</span>    <span class="n">exchange_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">g</span>
<span class="linenos">30</span>
<span class="linenos">31</span><span class="c1"># Hamiltonian of the spin-1/2 Heisenberg chain.</span>
<span class="linenos">32</span><span class="n">H</span> <span class="o">=</span> <span class="n">heisenberg</span><span class="p">(</span><span class="n">exchange_matrix</span><span class="p">)</span>
<span class="linenos">33</span>
<span class="linenos">34</span><span class="c1"># Total spin of the chain.</span>
<span class="linenos">35</span><span class="n">S_tot</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>
<span class="linenos">36</span>
<span class="linenos">37</span><span class="c1"># All three components of S commute with the Hamiltonian.</span>
<span class="linenos">38</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[H, S_x] =&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">H</span> <span class="o">*</span> <span class="n">S_tot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">S_tot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">H</span><span class="p">))</span>
<span class="linenos">39</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[H, S_y] =&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">H</span> <span class="o">*</span> <span class="n">S_tot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">S_tot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">H</span><span class="p">))</span>
<span class="linenos">40</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[H, S_z] =&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">H</span> <span class="o">*</span> <span class="n">S_tot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">S_tot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">H</span><span class="p">))</span>
<span class="linenos">41</span>
<span class="linenos">42</span><span class="c1"># Higher charge Q_3 (1st line of Eq. (10)).</span>
<span class="linenos">43</span><span class="n">Q3</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">cross</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">S</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">]),</span> <span class="n">S</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
<span class="linenos">44</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[H, Q3] =&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">H</span> <span class="o">*</span> <span class="n">Q3</span> <span class="o">-</span> <span class="n">Q3</span> <span class="o">*</span> <span class="n">H</span><span class="p">))</span>
<span class="linenos">45</span>
<span class="linenos">46</span><span class="c1"># Higher charge Q_4 (2nd line of Eq. (10)).</span>
<span class="linenos">47</span><span class="n">Q4</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">dot</span><span class="p">(</span>
<span class="linenos">48</span>    <span class="n">cross</span><span class="p">(</span>
<span class="linenos">49</span>        <span class="n">cross</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">S</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">]),</span> <span class="n">S</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">]</span>
<span class="linenos">50</span>    <span class="p">),</span> <span class="n">S</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
<span class="linenos">51</span><span class="n">Q4</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">S</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
<span class="linenos">52</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[H, Q4] =&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">H</span> <span class="o">*</span> <span class="n">Q4</span> <span class="o">-</span> <span class="n">Q4</span> <span class="o">*</span> <span class="n">H</span><span class="p">))</span>
<span class="linenos">53</span>
<span class="linenos">54</span><span class="c1"># Higher charge Q_5 (3rd line of Eq. (10)).</span>
<span class="linenos">55</span><span class="n">Q5</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">dot</span><span class="p">(</span>
<span class="linenos">56</span>    <span class="n">cross</span><span class="p">(</span>
<span class="linenos">57</span>        <span class="n">cross</span><span class="p">(</span>
<span class="linenos">58</span>            <span class="n">cross</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">S</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">]),</span>
<span class="linenos">59</span>            <span class="n">S</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">]</span>
<span class="linenos">60</span>        <span class="p">),</span> <span class="n">S</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">]),</span>
<span class="linenos">61</span>    <span class="n">S</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
<span class="linenos">62</span><span class="n">Q5</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">cross</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">S</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">]),</span> <span class="n">S</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
<span class="linenos">63</span><span class="n">Q5</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">cross</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">S</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">]),</span> <span class="n">S</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
<span class="linenos">64</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[H, Q5] =&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">H</span> <span class="o">*</span> <span class="n">Q5</span> <span class="o">-</span> <span class="n">Q5</span> <span class="o">*</span> <span class="n">H</span><span class="p">))</span>
<span class="linenos">65</span>
<span class="linenos">66</span><span class="c1"># Check that the higher charges pairwise commute.</span>
<span class="linenos">67</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[Q3, Q4] =&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">Q3</span> <span class="o">*</span> <span class="n">Q4</span> <span class="o">-</span> <span class="n">Q4</span> <span class="o">*</span> <span class="n">Q3</span><span class="p">))</span>
<span class="linenos">68</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[Q3, Q5] =&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">Q3</span> <span class="o">*</span> <span class="n">Q5</span> <span class="o">-</span> <span class="n">Q5</span> <span class="o">*</span> <span class="n">Q3</span><span class="p">))</span>
<span class="linenos">69</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[Q4, Q5] =&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">Q4</span> <span class="o">*</span> <span class="n">Q5</span> <span class="o">-</span> <span class="n">Q5</span> <span class="o">*</span> <span class="n">Q4</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="spectrum-of-tavis-cummings-model">
<h2>Spectrum of Tavis-Cummings model<a class="headerlink" href="#spectrum-of-tavis-cummings-model" title="Permalink to this heading"></a></h2>
<p>In this example we demonstrate how to use tools from the
<a class="reference internal" href="loperator_ref.html#module-pycommute.loperator" title="pycommute.loperator"><code class="xref py py-mod docutils literal notranslate"><span class="pre">loperator</span></code></a> module along with NumPy’s eigensolvers to
diagonalize Hamiltonians of simple quantum models.</p>
<p>We will consider a two-atom Jaynes-Cummings (Tavis-Cummings) Hamiltonian
<a class="reference internal" href="#tc68" id="id3"><span>[TC68]</span></a>, which models a system of two qubits coherently coupled via a bosonic
degree of freedom (quantum oscillator),</p>
<div class="math notranslate nohighlight">
\[\hat H = \epsilon (\hat S_{z,0} + \hat S_{z,1}) +
         \omega \hat a^\dagger \hat a
         + g_0 (\hat a^\dagger \hat S_{-,0} + \hat a \hat S_{+,0})
         + g_1 (\hat a^\dagger \hat S_{-,1} + \hat a \hat S_{+,1}).\]</div>
<p>An expression of this form can be conveniently generated by a single call to
<a class="reference internal" href="models_ref.html#pycommute.models.jaynes_cummings" title="pycommute.models.jaynes_cummings"><code class="xref py py-func docutils literal notranslate"><span class="pre">jaynes_cummings()</span></code></a>.</p>
<p>Since the occupation number of the bosonic mode can formally grow
to <span class="math notranslate nohighlight">\(+\infty\)</span>, we have to artificially restrict the dimension of the
bosonic Hilbert space in order to be able to construct a finite matrix
representation of our problem.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Performance of repeated calls to
<a class="reference internal" href="loperator_ref.html#pycommute.loperator.LOperatorR" title="pycommute.loperator.LOperatorR"><code class="xref py py-class docutils literal notranslate"><span class="pre">LOperatorR</span></code></a> or to
<a class="reference internal" href="loperator_ref.html#pycommute.loperator.LOperatorC" title="pycommute.loperator.LOperatorC"><code class="xref py py-class docutils literal notranslate"><span class="pre">LOperatorC</span></code></a> in order to construct
a matrix representation of a linear operator is limited by Python method
call overhead. For large-scale problems it is advised to call the utility
function <a class="reference internal" href="loperator_ref.html#pycommute.loperator.make_matrix" title="pycommute.loperator.make_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_matrix()</span></code></a>.</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">#</span>
<span class="linenos"> 2</span><span class="c1"># Diagonalization of a two-qubit Tavis-Cummings model.</span>
<span class="linenos"> 3</span><span class="c1">#</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="c1"># Utility function used to construct the generalized Jaynes-Cummings model.</span>
<span class="linenos"> 8</span><span class="kn">from</span> <span class="nn">pycommute.models</span> <span class="kn">import</span> <span class="n">jaynes_cummings</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="c1"># Hilbert spaces.</span>
<span class="linenos">11</span><span class="kn">from</span> <span class="nn">pycommute.loperator</span> <span class="kn">import</span> <span class="n">HilbertSpace</span><span class="p">,</span> <span class="n">make_space_boson</span><span class="p">,</span> <span class="n">make_space_spin</span>
<span class="linenos">12</span>
<span class="linenos">13</span><span class="c1"># Real-valued linear operator object.</span>
<span class="linenos">14</span><span class="kn">from</span> <span class="nn">pycommute.loperator</span> <span class="kn">import</span> <span class="n">LOperatorR</span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="c1"># Build the matrix form of a linear operator.</span>
<span class="linenos">17</span><span class="kn">from</span> <span class="nn">pycommute.loperator</span> <span class="kn">import</span> <span class="n">make_matrix</span>
<span class="linenos">18</span>
<span class="linenos">19</span><span class="c1"># Transition frequencies of qubits.</span>
<span class="linenos">20</span><span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
<span class="linenos">21</span>
<span class="linenos">22</span><span class="c1"># Oscillator frequency.</span>
<span class="linenos">23</span><span class="c1"># (In a more general case of M oscillators, omega would be a length-M array).</span>
<span class="linenos">24</span><span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.8</span><span class="p">])</span>
<span class="linenos">25</span>
<span class="linenos">26</span><span class="c1"># Qubit-oscillator coupling constants as a 2x1 array.</span>
<span class="linenos">27</span><span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">]])</span>
<span class="linenos">28</span>
<span class="linenos">29</span><span class="c1"># Create the Tavis-Cummings Hamiltonian.</span>
<span class="linenos">30</span><span class="n">H</span> <span class="o">=</span> <span class="n">jaynes_cummings</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
<span class="linenos">31</span>
<span class="linenos">32</span><span class="c1"># Construct state space of our problem as a direct product of two</span>
<span class="linenos">33</span><span class="c1"># two-dimensional Hilbert spaces (qubits) and one truncated bosonic Hilbert</span>
<span class="linenos">34</span><span class="c1"># space.</span>
<span class="linenos">35</span><span class="c1"># make_space_boson(4) returns the truncated bosonic space with allowed</span>
<span class="linenos">36</span><span class="c1"># occupation numbers N = 0, 1, ..., (2^4-1).</span>
<span class="linenos">37</span><span class="n">hs</span> <span class="o">=</span> <span class="n">HilbertSpace</span><span class="p">([</span>
<span class="linenos">38</span>    <span class="n">make_space_spin</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>  <span class="c1"># Qubit 1: spin-1/2, index 0</span>
<span class="linenos">39</span>    <span class="n">make_space_spin</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>  <span class="c1"># Qubit 2: spin-1/2, index 1</span>
<span class="linenos">40</span>    <span class="n">make_space_boson</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>      <span class="c1"># Oscillator, index 0</span>
<span class="linenos">41</span><span class="p">])</span>
<span class="linenos">42</span>
<span class="linenos">43</span><span class="c1"># Construct a linear operator corresponding to &#39;H&#39; and acting in the Hilbert</span>
<span class="linenos">44</span><span class="c1"># space &#39;hs&#39;.</span>
<span class="linenos">45</span><span class="n">H_op</span> <span class="o">=</span> <span class="n">LOperatorR</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">hs</span><span class="p">)</span>
<span class="linenos">46</span>
<span class="linenos">47</span><span class="c1">#</span>
<span class="linenos">48</span><span class="c1"># Prepare a matrix representation of &#39;H_op&#39;</span>
<span class="linenos">49</span><span class="c1">#</span>
<span class="linenos">50</span>
<span class="linenos">51</span><span class="c1"># Method I (manual).</span>
<span class="linenos">52</span><span class="n">H_mat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">hs</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">hs</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
<span class="linenos">53</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hs</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
<span class="linenos">54</span>    <span class="c1"># A column vector psi = {0, 0, ..., 1, ..., 0}</span>
<span class="linenos">55</span>    <span class="n">psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">hs</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
<span class="linenos">56</span>    <span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="linenos">57</span>    <span class="c1"># Act with H_op on psi and store the result the i-th column of H_mat</span>
<span class="linenos">58</span>    <span class="n">H_mat1</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">H_op</span> <span class="o">*</span> <span class="n">psi</span>
<span class="linenos">59</span>
<span class="linenos">60</span><span class="c1"># Method II (automatic and faster).</span>
<span class="linenos">61</span><span class="n">H_mat2</span> <span class="o">=</span> <span class="n">make_matrix</span><span class="p">(</span><span class="n">H_op</span><span class="p">,</span> <span class="n">hs</span><span class="p">)</span>
<span class="linenos">62</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Max difference between H_mat and H_mat2:&quot;</span><span class="p">,</span>
<span class="linenos">63</span>      <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">H_mat1</span> <span class="o">-</span> <span class="n">H_mat2</span><span class="p">)))</span>
<span class="linenos">64</span>
<span class="linenos">65</span><span class="c1"># Use NumPy to compute eigenvalues of H_mat</span>
<span class="linenos">66</span><span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">H_mat1</span><span class="p">)</span>
<span class="linenos">67</span>
<span class="linenos">68</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Energies:&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">E</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="sectors-of-a-multi-orbital-interaction-hamiltonian">
<h2>Sectors of a multi-orbital interaction Hamiltonian<a class="headerlink" href="#sectors-of-a-multi-orbital-interaction-hamiltonian" title="Permalink to this heading"></a></h2>
<p>When implementing an exact diagonalization algorithm, it is usually advantageous
to take an extra preparatory step and split the Hilbert space of the problem
into subspaces (sectors) characterized by a set of quantum numbers.
In many situations, it is possible to find the sectors even without knowing
the quantities conserved by the Hamiltonian (see, for instance, <a class="reference internal" href="#skfp16" id="id4"><span>[SKFP16]</span></a>).</p>
<p>In the script shown below we construct an electron-electron interaction
Hamiltonian of an atomic <span class="math notranslate nohighlight">\(d\)</span>-shell using
<a class="reference internal" href="models_ref.html#pycommute.models.slater_int" title="pycommute.models.slater_int"><code class="xref py py-func docutils literal notranslate"><span class="pre">Slater</span></code></a> parametrization. Then, we employ
the <a class="reference internal" href="loperator_ref.html#pycommute.loperator.SpacePartition" title="pycommute.loperator.SpacePartition"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpacePartition</span></code></a> and
<a class="reference internal" href="loperator_ref.html#pycommute.loperator.BasisMapper" title="pycommute.loperator.BasisMapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">BasisMapper</span></code></a> utility classes (and
optionally the <a class="reference internal" href="loperator_ref.html#pycommute.loperator.make_matrix" title="pycommute.loperator.make_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_matrix()</span></code></a> function)
to independently diagonalize the Hamiltonian within each sector.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">#</span>
<span class="linenos"> 2</span><span class="c1"># Sector-wise diagonalization of the Slater interaction Hamiltonian.</span>
<span class="linenos"> 3</span><span class="c1">#</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="c1"># Utility function used to construct the Slater interaction Hamiltonian.</span>
<span class="linenos"> 8</span><span class="kn">from</span> <span class="nn">pycommute.models</span> <span class="kn">import</span> <span class="n">slater_int</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="c1"># Hilbert space.</span>
<span class="linenos">11</span><span class="kn">from</span> <span class="nn">pycommute.loperator</span> <span class="kn">import</span> <span class="n">HilbertSpace</span>
<span class="linenos">12</span>
<span class="linenos">13</span><span class="c1"># Real-valued linear operator object.</span>
<span class="linenos">14</span><span class="kn">from</span> <span class="nn">pycommute.loperator</span> <span class="kn">import</span> <span class="n">LOperatorR</span>
<span class="linenos">15</span><span class="c1"># Automatic space partition and basis state mapper</span>
<span class="linenos">16</span><span class="kn">from</span> <span class="nn">pycommute.loperator</span> <span class="kn">import</span> <span class="n">make_space_partition</span><span class="p">,</span> <span class="n">BasisMapper</span>
<span class="linenos">17</span><span class="c1"># Build the matrix form of a linear operator</span>
<span class="linenos">18</span><span class="kn">from</span> <span class="nn">pycommute.loperator</span> <span class="kn">import</span> <span class="n">make_matrix</span>
<span class="linenos">19</span>
<span class="linenos">20</span><span class="c1"># Values of Slater radial integrals F^0, F^2, F^4</span>
<span class="linenos">21</span><span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">])</span>
<span class="linenos">22</span>
<span class="linenos">23</span><span class="c1"># Build an expression for the interaction Hamiltonian.</span>
<span class="linenos">24</span><span class="n">H</span> <span class="o">=</span> <span class="n">slater_int</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="linenos">25</span>
<span class="linenos">26</span><span class="c1"># Analyze structure of &#39;H&#39; and construct a suitable Hilbert space.</span>
<span class="linenos">27</span><span class="n">hs</span> <span class="o">=</span> <span class="n">HilbertSpace</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
<span class="linenos">28</span>
<span class="linenos">29</span><span class="c1"># Construct a linear operator corresponding to H and acting in the Hilbert</span>
<span class="linenos">30</span><span class="c1"># space &#39;hs&#39;.</span>
<span class="linenos">31</span><span class="n">H_op</span> <span class="o">=</span> <span class="n">LOperatorR</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">hs</span><span class="p">)</span>
<span class="linenos">32</span>
<span class="linenos">33</span><span class="c1"># The first value returned by &#39;make_space_partition()&#39; is a</span>
<span class="linenos">34</span><span class="c1"># SpacePartition object. It represents a partition of the full Hilbert space</span>
<span class="linenos">35</span><span class="c1"># into sectors, i.e. subspaces invariant under action of &#39;H_op&#39;.</span>
<span class="linenos">36</span><span class="c1">#</span>
<span class="linenos">37</span><span class="c1"># The second returned value is a dictionary {(i, j): value} of all non-vanishing</span>
<span class="linenos">38</span><span class="c1"># matrix elements of H_{ij}. By definition, all matrix elements of &#39;H_op&#39;</span>
<span class="linenos">39</span><span class="c1"># between different sectors vanish.</span>
<span class="linenos">40</span><span class="n">sp</span><span class="p">,</span> <span class="n">matrix_elements</span> <span class="o">=</span> <span class="n">make_space_partition</span><span class="p">(</span><span class="n">H_op</span><span class="p">,</span> <span class="n">hs</span><span class="p">)</span>
<span class="linenos">41</span>
<span class="linenos">42</span><span class="c1"># Print out information about the revealed sectors.</span>
<span class="linenos">43</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dimension of full Hilbert space:&quot;</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
<span class="linenos">44</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total number of sectors:&quot;</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">n_subspaces</span><span class="p">)</span>
<span class="linenos">45</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
<span class="linenos">46</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Many-body basis state </span><span class="si">%d</span><span class="s2"> belongs to sector </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
<span class="linenos">47</span>
<span class="linenos">48</span><span class="c1"># Compile lists of basis states spanning each sector.</span>
<span class="linenos">49</span><span class="n">sectors</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">subspace_bases</span><span class="p">()</span>
<span class="linenos">50</span>
<span class="linenos">51</span><span class="c1"># Diagonalize &#39;H_op&#39; within each sector</span>
<span class="linenos">52</span><span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">sector</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sectors</span><span class="p">):</span>
<span class="linenos">53</span>    <span class="n">sector_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sector</span><span class="p">)</span>
<span class="linenos">54</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Diagonalizing sector </span><span class="si">%d</span><span class="s2"> of H_op&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
<span class="linenos">55</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sector size is </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">sector_dim</span><span class="p">)</span>
<span class="linenos">56</span>
<span class="linenos">57</span>    <span class="c1"># A BasisMapper object translates indices of basis states from the full</span>
<span class="linenos">58</span>    <span class="c1"># Hilbert space to a given sector.</span>
<span class="linenos">59</span>    <span class="n">basis_mapper</span> <span class="o">=</span> <span class="n">BasisMapper</span><span class="p">(</span><span class="n">sector</span><span class="p">)</span>
<span class="linenos">60</span>
<span class="linenos">61</span>    <span class="c1">#</span>
<span class="linenos">62</span>    <span class="c1"># Prepare a matrix representation of &#39;H_op&#39; within current sector.</span>
<span class="linenos">63</span>    <span class="c1">#</span>
<span class="linenos">64</span>
<span class="linenos">65</span>    <span class="c1"># Method I (manual).</span>
<span class="linenos">66</span>    <span class="n">H_mat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sector_dim</span><span class="p">,</span> <span class="n">sector_dim</span><span class="p">))</span>
<span class="linenos">67</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sector_dim</span><span class="p">):</span>
<span class="linenos">68</span>        <span class="c1"># A column vector psi = {0, 0, ..., 1, ..., 0}</span>
<span class="linenos">69</span>        <span class="n">psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sector_dim</span><span class="p">)</span>
<span class="linenos">70</span>        <span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="linenos">71</span>        <span class="c1"># This vector will receive the result of H_op * psi</span>
<span class="linenos">72</span>        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sector_dim</span><span class="p">)</span>
<span class="linenos">73</span>
<span class="linenos">74</span>        <span class="c1"># Since both &#39;psi&#39; and &#39;phi&#39; are 1D NumPy arrays with size of the chosen</span>
<span class="linenos">75</span>        <span class="c1"># sector, &#39;H_op&#39; cannot act on them directly as it expects vectors of</span>
<span class="linenos">76</span>        <span class="c1"># size hs.dim.</span>
<span class="linenos">77</span>        <span class="c1"># Instead, we are going to use our basis mapper object to construct</span>
<span class="linenos">78</span>        <span class="c1"># special views of psi and phi.</span>
<span class="linenos">79</span>        <span class="n">psi_view</span> <span class="o">=</span> <span class="n">basis_mapper</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
<span class="linenos">80</span>        <span class="n">phi_view</span> <span class="o">=</span> <span class="n">basis_mapper</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
<span class="linenos">81</span>
<span class="linenos">82</span>        <span class="c1"># Now, &#39;H_op&#39; can act on the mapped views.</span>
<span class="linenos">83</span>        <span class="n">H_op</span><span class="p">(</span><span class="n">psi_view</span><span class="p">,</span> <span class="n">phi_view</span><span class="p">)</span>
<span class="linenos">84</span>
<span class="linenos">85</span>        <span class="c1"># Store H_op * psi in the i-th column of &#39;H_mat1&#39;.</span>
<span class="linenos">86</span>        <span class="n">H_mat1</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi</span>
<span class="linenos">87</span>
<span class="linenos">88</span>    <span class="c1"># Method II (automatic and faster).</span>
<span class="linenos">89</span>    <span class="n">H_mat2</span> <span class="o">=</span> <span class="n">make_matrix</span><span class="p">(</span><span class="n">H_op</span><span class="p">,</span> <span class="n">sector</span><span class="p">)</span>
<span class="linenos">90</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Max difference between H_mat and H_mat2:&quot;</span><span class="p">,</span>
<span class="linenos">91</span>          <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">H_mat1</span> <span class="o">-</span> <span class="n">H_mat2</span><span class="p">)))</span>
<span class="linenos">92</span>
<span class="linenos">93</span>    <span class="c1"># Use NumPy to compute eigenvalues of &#39;H_mat1&#39;.</span>
<span class="linenos">94</span>    <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">H_mat1</span><span class="p">)</span>
<span class="linenos">95</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Energies:&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">E</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="n-fermion-sector-views">
<h2>N-fermion sector views<a class="headerlink" href="#n-fermion-sector-views" title="Permalink to this heading"></a></h2>
<p>This example shows how to partially diagonalize the single band Fermi-Hubbard
model on a large 2D square lattice with periodic boundary conditions.</p>
<div class="math notranslate nohighlight">
\[\hat H = -t\sum_{\langle i,j \rangle, \sigma}
          c^\dagger_{i,\sigma} c_{j,\sigma}
          -\mu \sum_{i, \sigma} n_{i,\sigma}
          + U \sum_i n_{i,\uparrow} n_{i,\downarrow}.\]</div>
<p>The number of atoms in the considered lattice (cluster) is set to 16, which
makes for an intractably large Hilbert space of dimension <span class="math notranslate nohighlight">\(2^{32}\)</span>.
Since the Hamiltonian of the Hubbard model preserves total numbers of
spin-up and spin-down electrons, one can diagonalize the Hamiltonian within a
single <span class="math notranslate nohighlight">\(N\)</span>-fermion sector or within a
<span class="math notranslate nohighlight">\((N_\uparrow, N_\downarrow)\)</span>-multisector.</p>
<p>An <span class="math notranslate nohighlight">\(N\)</span>-fermion
<a class="reference internal" href="loperator_ref.html#pycommute.loperator.NFermionSectorViewR" title="pycommute.loperator.NFermionSectorViewR"><code class="xref py py-class docutils literal notranslate"><span class="pre">sector</span></code></a> is a subspace of
a full Hilbert space, which is spanned by all basis states with a fixed total
occupation of fermionic degrees of freedom (FDOF). Similarly, a
<a class="reference internal" href="loperator_ref.html#pycommute.loperator.NFermionMultiSectorViewR" title="pycommute.loperator.NFermionMultiSectorViewR"><code class="xref py py-class docutils literal notranslate"><span class="pre">multisector</span></code></a> is
spanned by all basis states with a fixed occupation <span class="math notranslate nohighlight">\(N_1\)</span> of a subset of
the FDOF <span class="math notranslate nohighlight">\(\{S_1\}\)</span>, occupation <span class="math notranslate nohighlight">\(N_2\)</span> of another subset
<span class="math notranslate nohighlight">\(\{S_2\}\)</span> and so on. There can be any number of pairs
<span class="math notranslate nohighlight">\((\{S_i\}, N_i)\)</span> (sectors contributing to the multisector) as long as
all the subsets <span class="math notranslate nohighlight">\(\{S_i\}\)</span> are disjoint.</p>
<p>In our example we consider a moderately sized sector with <span class="math notranslate nohighlight">\(N = 2\)</span>
(<span class="math notranslate nohighlight">\(\dim = {32 \choose 2} = 496\)</span>)
and a multisector with <span class="math notranslate nohighlight">\(N_\uparrow = 1, N_\downarrow = 1\)</span>
(<span class="math notranslate nohighlight">\(\dim = {16 \choose 1}{16 \choose 1} = 256\)</span>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general, the N-fermion (multi)sector views and functions do not require
a purely fermionic system. The definitions of a sector and a
multisector stand in presence of bosons or spins.</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">  1</span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="linenos">  2</span>
<span class="linenos">  3</span><span class="c1"># Utility functions used to construct the Fermi-Hubbard Hamiltonian.</span>
<span class="linenos">  4</span><span class="kn">from</span> <span class="nn">pycommute.models</span> <span class="kn">import</span> <span class="n">tight_binding</span><span class="p">,</span> <span class="n">dispersion</span><span class="p">,</span> <span class="n">hubbard_int</span>
<span class="linenos">  5</span>
<span class="linenos">  6</span><span class="c1"># Hilbert space.</span>
<span class="linenos">  7</span><span class="kn">from</span> <span class="nn">pycommute.loperator</span> <span class="kn">import</span> <span class="n">HilbertSpace</span>
<span class="linenos">  8</span>
<span class="linenos">  9</span><span class="c1"># Real-valued linear operator object.</span>
<span class="linenos"> 10</span><span class="kn">from</span> <span class="nn">pycommute.loperator</span> <span class="kn">import</span> <span class="n">LOperatorR</span>
<span class="linenos"> 11</span><span class="c1"># Real-valued N-fermion (multi)sector views and related functions</span>
<span class="linenos"> 12</span><span class="kn">from</span> <span class="nn">pycommute.loperator</span> <span class="kn">import</span> <span class="p">(</span>
<span class="linenos"> 13</span>    <span class="n">NFermionSectorViewR</span><span class="p">,</span>
<span class="linenos"> 14</span>    <span class="n">NFermionMultiSectorViewR</span><span class="p">,</span>
<span class="linenos"> 15</span>    <span class="n">n_fermion_sector_size</span><span class="p">,</span>
<span class="linenos"> 16</span>    <span class="n">n_fermion_multisector_size</span>
<span class="linenos"> 17</span><span class="p">)</span>
<span class="linenos"> 18</span>
<span class="linenos"> 19</span><span class="kn">from</span> <span class="nn">networkx.generators.lattice</span> <span class="kn">import</span> <span class="n">grid_2d_graph</span>
<span class="linenos"> 20</span><span class="kn">from</span> <span class="nn">networkx.linalg.graphmatrix</span> <span class="kn">import</span> <span class="n">adjacency_matrix</span>
<span class="linenos"> 21</span>
<span class="linenos"> 22</span><span class="c1">#</span>
<span class="linenos"> 23</span><span class="c1"># Let us define Hamiltonian of a tight-binding model on a square lattice.</span>
<span class="linenos"> 24</span><span class="c1">#</span>
<span class="linenos"> 25</span>
<span class="linenos"> 26</span><span class="c1"># Number of lattice sites in each direction</span>
<span class="linenos"> 27</span><span class="c1"># (the total number of sites is Nx * Ny).</span>
<span class="linenos"> 28</span><span class="n">Nx</span> <span class="o">=</span> <span class="mi">4</span>
<span class="linenos"> 29</span><span class="n">Ny</span> <span class="o">=</span> <span class="mi">4</span>
<span class="linenos"> 30</span>
<span class="linenos"> 31</span><span class="c1"># Hopping constant</span>
<span class="linenos"> 32</span><span class="n">t</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="linenos"> 33</span><span class="c1"># Chemical potential</span>
<span class="linenos"> 34</span><span class="n">mu</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="linenos"> 35</span><span class="c1"># Coulomb repulsion</span>
<span class="linenos"> 36</span><span class="n">U</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="linenos"> 37</span>
<span class="linenos"> 38</span><span class="c1"># Use NetworkX to construct the periodic square lattice (graph)</span>
<span class="linenos"> 39</span><span class="n">lat</span> <span class="o">=</span> <span class="n">grid_2d_graph</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="linenos"> 40</span>
<span class="linenos"> 41</span><span class="c1"># Create lists of indices for spin-up and spin-down operators.</span>
<span class="linenos"> 42</span><span class="c1"># lat.nodes() returns a list of Nx * Ny pairs of site indices (x, y).</span>
<span class="linenos"> 43</span><span class="n">indices_up</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot;up&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">lat</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>
<span class="linenos"> 44</span><span class="n">indices_dn</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">lat</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>
<span class="linenos"> 45</span>
<span class="linenos"> 46</span><span class="c1"># A sum of tight-binding Hamiltonians for both spins.</span>
<span class="linenos"> 47</span><span class="c1"># The hopping matrix passed to tight_binding() is proportional to the</span>
<span class="linenos"> 48</span><span class="c1"># adjacency matrix of the lattice.</span>
<span class="linenos"> 49</span><span class="n">hopping_matrix</span> <span class="o">=</span> <span class="o">-</span><span class="n">t</span> <span class="o">*</span> <span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>
<span class="linenos"> 50</span><span class="n">H</span> <span class="o">=</span> <span class="n">tight_binding</span><span class="p">(</span><span class="n">hopping_matrix</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices_up</span><span class="p">)</span> \
<span class="linenos"> 51</span>    <span class="o">+</span> <span class="n">tight_binding</span><span class="p">(</span><span class="n">hopping_matrix</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices_dn</span><span class="p">)</span>
<span class="linenos"> 52</span>
<span class="linenos"> 53</span><span class="c1"># Add the chemical potential terms</span>
<span class="linenos"> 54</span><span class="n">H</span> <span class="o">+=</span> <span class="n">dispersion</span><span class="p">(</span><span class="o">-</span><span class="n">mu</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices_up</span><span class="p">)),</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices_up</span><span class="p">)</span>
<span class="linenos"> 55</span><span class="n">H</span> <span class="o">+=</span> <span class="n">dispersion</span><span class="p">(</span><span class="o">-</span><span class="n">mu</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices_dn</span><span class="p">)),</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices_dn</span><span class="p">)</span>
<span class="linenos"> 56</span>
<span class="linenos"> 57</span><span class="c1"># Add the Hubbard interaction term</span>
<span class="linenos"> 58</span><span class="n">H</span> <span class="o">+=</span> <span class="n">hubbard_int</span><span class="p">(</span><span class="n">U</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices_up</span><span class="p">)),</span>
<span class="linenos"> 59</span>                 <span class="n">indices_up</span><span class="o">=</span><span class="n">indices_up</span><span class="p">,</span>
<span class="linenos"> 60</span>                 <span class="n">indices_dn</span><span class="o">=</span><span class="n">indices_dn</span><span class="p">)</span>
<span class="linenos"> 61</span>
<span class="linenos"> 62</span><span class="c1"># Analyze structure of H and construct a suitable Hilbert space.</span>
<span class="linenos"> 63</span><span class="n">hs</span> <span class="o">=</span> <span class="n">HilbertSpace</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
<span class="linenos"> 64</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Full Hilbert space dimension:&quot;</span><span class="p">,</span> <span class="n">hs</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
<span class="linenos"> 65</span>
<span class="linenos"> 66</span><span class="c1"># Construct a linear operator corresponding to H and acting in the Hilbert</span>
<span class="linenos"> 67</span><span class="c1"># space &#39;hs&#39;.</span>
<span class="linenos"> 68</span><span class="n">H_op</span> <span class="o">=</span> <span class="n">LOperatorR</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">hs</span><span class="p">)</span>
<span class="linenos"> 69</span>
<span class="linenos"> 70</span><span class="c1">#</span>
<span class="linenos"> 71</span><span class="c1"># Diagonalize the N = 2 sector of the model using &#39;NFermionSectorViewR&#39;</span>
<span class="linenos"> 72</span><span class="c1">#</span>
<span class="linenos"> 73</span>
<span class="linenos"> 74</span><span class="n">N</span> <span class="o">=</span> <span class="mi">2</span>
<span class="linenos"> 75</span>
<span class="linenos"> 76</span><span class="n">sector_size</span> <span class="o">=</span> <span class="n">n_fermion_sector_size</span><span class="p">(</span><span class="n">hs</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="linenos"> 77</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Size of the N = 2 sector:&quot;</span><span class="p">,</span> <span class="n">sector_size</span><span class="p">)</span>
<span class="linenos"> 78</span>
<span class="linenos"> 79</span><span class="c1"># Prepare a matrix representation of H_op within the N = 2 sector.</span>
<span class="linenos"> 80</span><span class="n">H_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sector_size</span><span class="p">,</span> <span class="n">sector_size</span><span class="p">))</span>
<span class="linenos"> 81</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sector_size</span><span class="p">):</span>
<span class="linenos"> 82</span>    <span class="c1"># A column vector psi = {0, 0, ..., 1, ..., 0}</span>
<span class="linenos"> 83</span>    <span class="n">psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sector_size</span><span class="p">)</span>
<span class="linenos"> 84</span>    <span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="linenos"> 85</span>    <span class="c1"># This vector will receive the result of H_op * psi</span>
<span class="linenos"> 86</span>    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sector_size</span><span class="p">)</span>
<span class="linenos"> 87</span>
<span class="linenos"> 88</span>    <span class="c1"># Since both psi and phi are 1D NumPy arrays with size of the chosen</span>
<span class="linenos"> 89</span>    <span class="c1"># sector, H_op cannot act on them directly as it expects vectors of</span>
<span class="linenos"> 90</span>    <span class="c1"># size hs.dim.</span>
<span class="linenos"> 91</span>    <span class="c1"># Instead, we are going to use real-valued 2-fermion sector views of</span>
<span class="linenos"> 92</span>    <span class="c1"># psi and phi.</span>
<span class="linenos"> 93</span>    <span class="n">psi_view</span> <span class="o">=</span> <span class="n">NFermionSectorViewR</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">hs</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="linenos"> 94</span>    <span class="n">phi_view</span> <span class="o">=</span> <span class="n">NFermionSectorViewR</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">hs</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="linenos"> 95</span>
<span class="linenos"> 96</span>    <span class="c1"># Now, H_op can act on the mapped views.</span>
<span class="linenos"> 97</span>    <span class="n">H_op</span><span class="p">(</span><span class="n">psi_view</span><span class="p">,</span> <span class="n">phi_view</span><span class="p">)</span>
<span class="linenos"> 98</span>
<span class="linenos"> 99</span>    <span class="c1"># Store H_op * psi in the i-th column of H_mat.</span>
<span class="linenos">100</span>    <span class="n">H_mat</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi</span>
<span class="linenos">101</span>
<span class="linenos">102</span><span class="c1"># Use NumPy to compute eigenvalues of H_mat.</span>
<span class="linenos">103</span><span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">H_mat</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
<span class="linenos">104</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;10 lowest eigenvalues of the N = 2 sector:&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">E</span><span class="p">)[:</span><span class="mi">10</span><span class="p">])</span>
<span class="linenos">105</span>
<span class="linenos">106</span><span class="c1">#</span>
<span class="linenos">107</span><span class="c1"># Diagonalize the N_up = 1, N_down = 1 multisector of the model using</span>
<span class="linenos">108</span><span class="c1"># &#39;NFermionMultiSectorViewR&#39;</span>
<span class="linenos">109</span><span class="c1">#</span>
<span class="linenos">110</span>
<span class="linenos">111</span><span class="n">N_up</span> <span class="o">=</span> <span class="mi">1</span>
<span class="linenos">112</span><span class="n">N_dn</span> <span class="o">=</span> <span class="mi">1</span>
<span class="linenos">113</span>
<span class="linenos">114</span><span class="c1"># Define sectors contributing to the multisector</span>
<span class="linenos">115</span><span class="n">sector_up</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices_up</span><span class="p">,</span> <span class="n">N_up</span><span class="p">)</span>
<span class="linenos">116</span><span class="n">sector_dn</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices_dn</span><span class="p">,</span> <span class="n">N_dn</span><span class="p">)</span>
<span class="linenos">117</span>
<span class="linenos">118</span><span class="n">sectors</span> <span class="o">=</span> <span class="p">[</span><span class="n">sector_up</span><span class="p">,</span> <span class="n">sector_dn</span><span class="p">]</span>
<span class="linenos">119</span>
<span class="linenos">120</span><span class="n">multisector_size</span> <span class="o">=</span> <span class="n">n_fermion_multisector_size</span><span class="p">(</span><span class="n">hs</span><span class="p">,</span> <span class="n">sectors</span><span class="p">)</span>
<span class="linenos">121</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Size of the N_up = 1, N_down = 1 multisector:&quot;</span><span class="p">,</span> <span class="n">multisector_size</span><span class="p">)</span>
<span class="linenos">122</span>
<span class="linenos">123</span><span class="c1"># Prepare a matrix representation of H_op within the multisector.</span>
<span class="linenos">124</span><span class="n">H_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">multisector_size</span><span class="p">,</span> <span class="n">multisector_size</span><span class="p">))</span>
<span class="linenos">125</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">multisector_size</span><span class="p">):</span>
<span class="linenos">126</span>    <span class="c1"># A column vector psi = {0, 0, ..., 1, ..., 0}</span>
<span class="linenos">127</span>    <span class="n">psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">multisector_size</span><span class="p">)</span>
<span class="linenos">128</span>    <span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="linenos">129</span>    <span class="c1"># This vector will receive the result of H_op * psi</span>
<span class="linenos">130</span>    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">multisector_size</span><span class="p">)</span>
<span class="linenos">131</span>
<span class="linenos">132</span>    <span class="c1"># Since both psi and phi are 1D NumPy arrays with size of the chosen</span>
<span class="linenos">133</span>    <span class="c1"># sector, H_op cannot act on them directly as it expects vectors of</span>
<span class="linenos">134</span>    <span class="c1"># size hs.dim.</span>
<span class="linenos">135</span>    <span class="c1"># Instead, we are going to use real-valued multisector views of psi and phi.</span>
<span class="linenos">136</span>    <span class="n">psi_view</span> <span class="o">=</span> <span class="n">NFermionMultiSectorViewR</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">hs</span><span class="p">,</span> <span class="n">sectors</span><span class="p">)</span>
<span class="linenos">137</span>    <span class="n">phi_view</span> <span class="o">=</span> <span class="n">NFermionMultiSectorViewR</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">hs</span><span class="p">,</span> <span class="n">sectors</span><span class="p">)</span>
<span class="linenos">138</span>
<span class="linenos">139</span>    <span class="c1"># Now, H_op can act on the mapped views.</span>
<span class="linenos">140</span>    <span class="n">H_op</span><span class="p">(</span><span class="n">psi_view</span><span class="p">,</span> <span class="n">phi_view</span><span class="p">)</span>
<span class="linenos">141</span>
<span class="linenos">142</span>    <span class="c1"># Store H_op * psi in the i-th column of H_mat.</span>
<span class="linenos">143</span>    <span class="n">H_mat</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi</span>
<span class="linenos">144</span>
<span class="linenos">145</span><span class="c1"># Use NumPy to compute eigenvalues of H_mat.</span>
<span class="linenos">146</span><span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">H_mat</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
<span class="linenos">147</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;10 lowest eigenvalues of the multisector:&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">E</span><span class="p">)[:</span><span class="mi">10</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this heading"></a></h2>
<div role="list" class="citation-list">
<div class="citation" id="gm94" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">GM94</a><span class="fn-bracket">]</span></span>
<p>“Quantum Integrals of Motion for the Heisenberg Spin Chain”,
M. P. Grabowski and P. Mathieu,
Mod. Phys. Lett. A, Vol. 09, No. 24, pp. 2197-2206 (1994),
<a class="reference external" href="https://doi.org/10.1142/S0217732394002057">https://doi.org/10.1142/S0217732394002057</a></p>
</div>
<div class="citation" id="tc68" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">TC68</a><span class="fn-bracket">]</span></span>
<p>“Exact Solution for an N-Molecule-Radiation-Field Hamiltonian”,
M. Tavis and F. W. Cummings
Phys. Rev. 170, 379 (1968)
<a class="reference external" href="https://doi.org/10.1103/PhysRev.170.379">https://doi.org/10.1103/PhysRev.170.379</a></p>
</div>
<div class="citation" id="skfp16" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">SKFP16</a><span class="fn-bracket">]</span></span>
<p>“TRIQS/CTHYB: A continuous-time quantum Monte Carlo
hybridisation expansion solver for quantum impurity problems”,
P. Seth, I. Krivenko, M. Ferrero and O. Parcollet,
Comp. Phys. Comm. 200, March 2016, 274-284,
<a class="reference external" href="http://dx.doi.org/10.1016/j.cpc.2015.10.023">http://dx.doi.org/10.1016/j.cpc.2015.10.023</a> (section 4.2)</p>
</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="installation.html" class="btn btn-neutral float-left" title="Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="reference.html" class="btn btn-neutral float-right" title="API reference" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2021, Igor Krivenko.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>