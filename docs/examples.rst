.. _examples:

Usage examples
==============

Holstein model
--------------

This example shows how to construct Hamiltonian of the
`Holstein model <https://arxiv.org/abs/cond-mat/9812252>`_ on a
square lattice and to check that the total number of electrons is a conserved
quantity of the model.

The Hamiltonian considered here is a sum of three terms.

* An electronic tight-binding model on a square lattice with only
  nearest-neighbour hopping allowed,

  .. math::

    \hat H_\text{e} = -t \sum_\sigma \sum_{\langle i,j\rangle}
                      c^\dagger_{i,\sigma} c_{j,\sigma}.

* A harmonic oscillator at each lattice site (a localized phonon),

  .. math::

    \hat H_\text{ph} = \omega_0 \sum_i a^\dagger_i a_i.

* A coupling between the electrons and the phonons.

  .. math::

    \hat H_\text{e-ph} = g \sum_\sigma \sum_i n_{i,\sigma}(a^\dagger_i + a_i).

Instead of writing the sums over lattice sites explicitly, we call library
functions :func:`tight_binding() <pycommute.models.tight_binding>`,
:func:`dispersion() <pycommute.models.dispersion>` and
:func:`holstein_int() <pycommute.models.holstein_int>`.
We also make use of the `NetworkX <https://networkx.org/>`_ package
to easily generate the adjacency matrix of the periodic square lattice.

.. literalinclude:: examples/holstein.py
  :language: python
  :lines: 11-
  :linenos:

Spin-1/2 Heisenberg chain
-------------------------

The spin-1/2 Heisenberg chain is a textbook example of an integrable quantum
system. Its Hamiltonian

.. math::

  \hat H = g \sum_i \mathbf{S}_i \cdot \mathbf{S}_{i+1}

conserves three projections of the total spin

.. math::

  \mathbf{S} = \sum_i \mathbf{S}_i

as well as a series of higher order charges :math:`Q_n`. Existence of these
charges can be derived from the transfer matrix theory. Explicit expressions
for :math:`Q_n` were obtained in [GM94]_. The following script constructs
Hamiltonian of the Heisenberg chain with periodic boundary conditions
(see :func:`heisenberg() <pycommute.models.heisenberg>`)
and checks that :math:`[\hat H, \mathbf{S}] = 0`, :math:`[\hat H, Q_n] = 0` and
:math:`[Q_n, Q_m] = 0` for :math:`m,n = 3,4,5`.

.. literalinclude:: examples/heisenberg_chain.py
  :language: python
  :lines: 11-
  :linenos:

Spectrum of Tavis-Cummings model
--------------------------------

In this example we demonstrate how to use tools from the
:mod:`loperator <pycommute.loperator>` module along with NumPy's eigensolvers to
diagonalize Hamiltonians of simple quantum models.

We will consider a two-atom Jaynes-Cummings (Tavis-Cummings) Hamiltonian
[TC68]_, which models a system of two qubits coherently coupled via a bosonic
degree of freedom (quantum oscillator),

.. math::

  \hat H = \epsilon (\hat S_{z,0} + \hat S_{z,1}) +
           \omega \hat a^\dagger \hat a
           + g_0 (\hat a^\dagger \hat S_{-,0} + \hat a \hat S_{+,0})
           + g_1 (\hat a^\dagger \hat S_{-,1} + \hat a \hat S_{+,1}).

An expression of this form can be conveniently generated by a single call to
:func:`jaynes_cummings() <pycommute.models.jaynes_cummings>`.

Since the occupation number of the bosonic mode can formally grow
to :math:`+\infty`, we have to artificially restrict the dimension of the
bosonic Hilbert space in order to be able to construct a finite matrix
representation of our problem.

.. note::

  Performance of repeated calls to
  :class:`LOperatorR <pycommute.loperator.LOperatorR>` or
  :class:`LOperatorC <pycommute.loperator.LOperatorC>` to construct a matrix
  representation of a linear operator is limited by Python method
  call overhead. For large-scale problems it is advised to construct the matrix
  in the C++ code using *libcommute*'s
  `ED tools <https://krivenko.github.io/libcommute/loperator/index.html>`_.

.. literalinclude:: examples/tavis_cummings.py
  :language: python
  :lines: 11-
  :linenos:

Sectors of a multi-orbital interaction Hamiltonian
--------------------------------------------------

When implementing an exact diagonalization algorithm, it is usually advantageous
to take an extra preparatory step and split the Hilbert space of the problem
into subspaces (sectors) characterized by a set of quantum numbers.
In many situations, it is possible to find the sectors even without knowing
the quantities conserved by the Hamiltonian (see, for instance, [SKFP16]_).

In the script shown below we construct an electron-electron interaction
Hamiltonian of an atomic :math:`d`-shell using
:func:`Slater <pycommute.models.slater_int>` parametrization. Then, we employ
the :class:`SpacePartition <pycommute.loperator.SpacePartition>` and
:class:`BasisMapper <pycommute.loperator.BasisMapper>` utility classes to
independently diagonalize the Hamiltonian within each sector.

.. literalinclude:: examples/space_partition.py
  :language: python
  :lines: 11-
  :linenos:

References
----------

.. [GM94] "Quantum Integrals of Motion for the Heisenberg Spin Chain",
  M. P. Grabowski and P. Mathieu,
  Mod. Phys. Lett. A, Vol. 09, No. 24, pp. 2197-2206 (1994),
  https://doi.org/10.1142/S0217732394002057

.. [TC68] "Exact Solution for an N-Molecule-Radiation-Field Hamiltonian",
  M. Tavis and F. W. Cummings
  Phys. Rev. 170, 379 (1968)
  https://doi.org/10.1103/PhysRev.170.379

.. [SKFP16] "TRIQS/CTHYB: A continuous-time quantum Monte Carlo
  hybridisation expansion solver for quantum impurity problems",
  P. Seth, I. Krivenko, M. Ferrero and O. Parcollet,
  Comp. Phys. Comm. 200, March 2016, 274-284,
  http://dx.doi.org/10.1016/j.cpc.2015.10.023 (section 4.2)
